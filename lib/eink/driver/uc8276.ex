defmodule EInk.Driver.UC8276 do
  use EInk.Driver, width: 400, height: 300, palette: :bw, partial_refresh: true

  defmodule State do
    defstruct [:spi, :dc, :reset, :busy, :current_lut, :debug]
  end

  alias Circuits.GPIO
  alias Circuits.SPI

  require Logger

  @lut %{
    full: %{
      0x20 =>
        <<0x01, 0x14, 0x0A, 0x14, 0x00, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00>>,
      0x21 =>
        <<0x01, 0x54, 0x0A, 0x94, 0x00, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00>>,
      0x22 =>
        <<0x01, 0x54, 0x0A, 0x94, 0x00, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00>>,
      0x23 =>
        <<0x01, 0x94, 0x0A, 0x54, 0x00, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00>>,
      0x24 =>
        <<0x01, 0x94, 0x0A, 0x54, 0x00, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00>>
    },
    partial: %{
      0x20 =>
        <<0x01, 0x14, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00>>,
      0x21 =>
        <<0x01, 0x14, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00>>,
      0x22 =>
        <<0x01, 0x94, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00>>,
      0x23 =>
        <<0x01, 0x54, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00>>,
      0x24 =>
        <<0x01, 0x14, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00>>
    }
  }

  @impl true
  def new(opts \\ []) do
    dc_pin = Keyword.get(opts, :dc_pin) || raise "Parameter `:dc_pin` is required"
    reset_pin = Keyword.get(opts, :reset_pin) || raise "Parameter `:reset_pin` is required"
    busy_pin = Keyword.get(opts, :busy_pin) || raise "Parameter `:busy_pin` is required"
    spi_device = Keyword.get(opts, :spi_device) || raise "Parameter `:spi_device` is required"
    debug = Keyword.get(opts, :debug, false)

    {:ok, dc} = GPIO.open(dc_pin, :output, initial_value: 0)
    {:ok, reset} = GPIO.open(reset_pin, :output, initial_value: 1)
    {:ok, busy} = GPIO.open(busy_pin, :input)

    {:ok, spi} = SPI.open(spi_device, mode: 0, speed_hz: 100_000)

    {:ok,
     %__MODULE__.State{
       spi: spi,
       dc: dc,
       reset: reset,
       busy: busy,
       current_lut: nil,
       debug: debug
     }}
  end

  @impl true
  def reset(%__MODULE__.State{} = epd) do
    if epd.debug, do: Logger.debug("UC8276 hardware reset")

    :ok = GPIO.write(epd.reset, 0)
    :ok = Process.sleep(100)
    :ok = GPIO.write(epd.reset, 1)

    {:ok, epd}
  end

  @impl true
  def sleep(%__MODULE__.State{} = epd) do
    if epd.debug, do: Logger.debug("UC8276 entering deep sleep")

    write(epd, 0x07, <<0xA5>>)
  end

  @impl true
  def wake(%__MODULE__.State{} = epd) do
    if epd.debug, do: Logger.debug("UC8276 waking up")

    {:ok, epd} = reset(epd)
    init(epd)
  end

  defp wait_for_busy(%__MODULE__.State{} = epd, opts \\ []) do
    if epd.debug, do: Logger.debug("UC8276 wait for busy flag")

    timeout = Keyword.get(opts, :timeout, 1000)
    polarity = Keyword.get(opts, :polarity, :active_low)

    Stream.repeatedly(fn ->
      Process.sleep(1)
      {GPIO.read(epd.busy), polarity}
    end)
    |> Stream.take(timeout)
    |> Enum.reduce_while({:error, :timeout}, fn
      {1, :active_high}, acc -> {:cont, acc}
      {0, :active_low}, acc -> {:cont, acc}
      _value, _acc -> {:halt, :ok}
    end)
  end

  defp write(%__MODULE__.State{} = epd, command, data) when is_binary(data) do
    if epd.debug,
      do:
        Logger.debug(
          "UC8276 Command: 0x#{Integer.to_string(command, 16) |> String.pad_leading(2, "0")}"
        )

    :ok = GPIO.write(epd.dc, 0)
    {:ok, _data} = SPI.transfer(epd.spi, <<command>>)

    if data != "" do
      :ok = GPIO.write(epd.dc, 1)

      for chunk <- chunk(data), chunk != "" do
        cond do
          not epd.debug -> :ok
          byte_size(data) <= 128 -> Logger.debug("UC8276 Data: #{debug_hex_str(chunk)}")
          true -> Logger.debug("UC8276 Data: #{byte_size(chunk)} bytes")
        end

        {:ok, _data} = SPI.transfer(epd.spi, chunk)
      end
    end

    :ok
  end

  @impl true
  def init(%__MODULE__.State{} = epd, _opts \\ []) do
    # Panel settings: 400x300 resolution, shift directions (u/d and l/r)
    write(epd, 0x00, <<0x3F, 0x4D>>)

    # Power settings
    write(epd, 0x01, <<0x03, 0x10, 0x3F, 0x3F, 0x03>>)

    # Booster soft start settings
    write(epd, 0x06, <<0x96, 0x96, 0x29>>)

    # PLL clock frequency setting
    write(epd, 0x30, <<0x09>>)

    # Resolution setting. This corresponds to 400x300
    write(epd, 0x61, <<0x01, 0x90, 0x01, 0x2C>>)

    # VCOM DC voltage setting
    write(epd, 0x82, <<0x05>>)

    # Border LUT setting
    write(epd, 0x50, <<0x97>>)

    # Gate/source overlap setting
    write(epd, 0x60, <<0x22>>)

    # Power saving setting
    write(epd, 0xE3, <<0x88>>)

    # Temperature sensor enabled, calibration offset 0
    write(epd, 0x41, <<0x00>>)

    {:ok, epd}
  end

  @impl true
  def draw(%__MODULE__.State{} = epd, image, opts \\ []) when is_binary(image) do
    write(epd, 0x13, image)

    use_lut = Keyword.get(opts, :refresh_type, :full)

    cond do
      epd.current_lut == use_lut -> :ok
      true -> load_lut(epd, @lut[use_lut])
    end

    write(epd, 0x17, <<0xA5>>)
    wait_for_busy(epd)

    {:ok, put_in(epd.current_lut, use_lut)}
  end

  defp load_lut(%__MODULE__.State{} = epd, lut) do
    for {reg, lut_data} <- lut do
      write(epd, reg, lut_data)
    end
  end

  defp chunk(""), do: []
  defp chunk(<<chunk::binary-size(1024), rest::binary>>), do: [chunk | chunk(rest)]
  defp chunk(remainder), do: [remainder]

  defp debug_hex_str(bytes) do
    :binary.bin_to_list(bytes)
    |> Enum.map(fn byte ->
      byte
      |> Integer.to_string(16)
      |> String.pad_leading(2, "0")
      |> then(&"0x#{&1}")
    end)
    |> Enum.join(", ")
  end
end
